## 1

1. 路由组件和非路由组件的区别

   > 使用都是三大步 定义 注册 使用
   > 定义 定义都一样，只是存放的文件夹不同
   > 注册 非路由组件是注册在要使用的组件中 路由组件要注册在路由配置中
   > 使用 非路由组件使用注册的组件标签 路由组件使用声明式导航(router-link, router-view)和编程式导航(push replace)
   > 生命周期不同 路由组件切换时会销毁重建(keep-alive)，而非路由不会

## 2 遍历数组

> for 循环 for..in forEach for...of
>
> - for 循环是 js 当中最简单的遍历方法 主要是针对数组进行遍历的，效率不高，但是可以使用 continue 和 break
> - for..in 循环主要是用来遍历对象的（遍历对象的可枚举属性的） 效率最低，原因是因为不但要遍历自身的属性还要遍历原型的
> - forEach 一个方法，主要是用来遍历数组的，效率最高，但是不可以使用 continue 和 break
> - for..of 是 es6 里面新加的一种遍历方法，效率没有 forEach 高（比其它的要高），也可以使用 continue 和 break，for..of 只能针对可迭代对象
>
> 遍历对象最快的方法也是使用 forEach 是把对象属性转化为数组然后进行遍历
> Object.keys(searchParams) 是把一个对象转化为数组，这个数组当中存储的是这个对象所有的属性名
> Object.keys(searchParams) 就是为了让对象可以使用 forEach 方法来高效去遍历

## 3 路由懒加载

> import 函数可以让文件单独打包，并且动态加载，第一次访问时才会调用 import 访问对应的 js 打包文件 `const Home = () => import('@/pages/Home')`
> import from 会打包成一个大文件，浏览器访问时效率不高

## 4 组件间通信

1. 组件间通信 props(一)

   - props 子组件声明接收属性三种写法 `['todos']` `{ todos: Array }` `{ todos: {type: Array, default: []} }`
   - 父子之间
     父可以给子传递(非函数和函数) 传非函数数据就是父给子 传函数数据 本质是父想要子的数据
   - 特殊:
     路由配置 props(三种）路由组件之间没有标签，但是可以把参数通过路由映射为属性
     1、布尔值 true 把路径 params 参数映射为要显示的组件内属性
     2、对象 {name : '赵丽颖'} 只能映射传递额外的静态的数据 一般不用
     3、函数 props: (route) => {} 自己手动映射 params 参数和 query 参数成为要显示的组件内属性
     如果不用 props，那么组件内要用数据必须要写成 this.$route.params.xxx this.$route.query.xxx

2. 组件间通信 自定义事件(二)

   - 自定义事件
     子向父传递数据
   - 原生 dom 事件
     事件类型 回调函数 谁调用 默认传递的实参是什么
     1、事件类型 固定的几个
     2、回调函数 自己去定义的
     3、触发(分发、触发事件)了谁调用 系统调用浏览器去调用
     4、event 事件对象 浏览器调用回调函数的时候传递的默认参数 box.onclick = function(event){}
   - 自定义事件
     事件类型 回调函数 谁调用 默认传递的是什么
     1、事件类型 无数个
     2、回调函数 自己去定义的
     3、谁调用 自己去调用自己使用$emit触发调用的
     4、默认传递的是什么 默认传递的是自己给的参数 (有就有，没有就没有undefined) this.$emit('haha', 10)
   - 原生 dom 事件在 html 标签和组件标签上的区别(Event1 组件测试)
     在 html 标签上添加就是原生的 dom 事件
     在组件标签上添加就是自定义事件，想成为原生的事件得添加修饰符, native,就是把原生 dom 事件添加到组件根元素上(事件委派了)
   - vue 自定义的事件在 html 标签和组件标签上的区别(Event2 组件测试)
     在 html 标签上添加自定义事件无意义，所以自定义事件是给组件标签添加的
     事件名可以任意，也可以和原生的 dom 事件名相同，但是在组件标签身上即使绑定原生 dom 事件的事件名，该事件也是自定义的

3. 全局事件总线(三)

   - 所有场合
   - 本质是一个对象
   - 全局事件总线的角色标准
     1、所有的组件对象都可以看到它
     2、可以使用 $on 和 $emit 方法
   - 怎么添加事件总线
     1、安装总线 本质就是在 Vue 的原型上挂上 vm 作为总线
     2、在接收数据的组件对象当中 获取总线给总线绑定自定义事件 this.$bus.$on
     3、在发送数据的组件对象当中 获取总线触发总线身上绑定的自定义事件 this.$bus.$emit

4. v-model 深入(四)
   element-ui 表单相关项都使用到了 v-model
   官方网站也提出了怎么去使用

   - 1、html input v- -mode |的本质
     `:value = "data"` //读取数据
     `@input = "data = $event.target.value"` //写数据

   - 2、组件标签上 v-modeI 本质
     `:value = "data"` //父组件传递属性给子组件，子组件需要接受
     `@input = "data = $event"` //父组件当中给子组件添加的自定义事件
     数据在父组件当中

     子组件当中必须这样写
     先接受 `props:['value']`

     子组件表单类元素

     > `:value = "value"` > `@input = "$emit('input', $event.target.value)"`

   - 干了两件事
     先显示数据 再绑定修改数据的事件
     只不过在 html 和组件标签上绑定的 @input 事件不同 一个是原生的一个是自定义的事件

   - 实现父子组件双向数据同步问题

   - 本质上还是自定义事件和 props 组合

5. sync 属性修饰符(五)

   - 实现父子组件双向数据同步问题 和 v-model 实现效果几乎一样
   - v-model 一般用于带表单项的组件
   - sync 属性修饰符一般用于不带表单项的组件

   - 父组件给子组件属性传递数据后面添加.sync
   - 子组件修改数据需要分发事件 `@click = "$emit('update:属性名', 要更新的数据)"`
   - 本质上还是自定义事件和 props 组合

6. `$attrs` 和 `$linsteners` (六)

   - 对一个组件进行二次封装
   - 本质就是父组件中给子组件传递的所有属性组成的对象及自定义事件方法组成的对象
   - `$attrs`如果不声明 props 那么子组件当中`$attrs` 是可以看到如果 声明了哪个属性，那么那个属性在`$attrs` 当中看不到
     它会排除 props 声明接收的属性以及 class style
   - 可以通过 v-bind 一次性把父组件传递过来的属性添加给子组件
   - 可以通过 v-on 一次性把父组件传递过来的事件监听添加给子组件
   - 对一个组件进行二次封装

7. element-ui 的 button 添加 click 事件会触发，添加 dblclick 就不会触发的问题

   element-ui 的 button 子组件内部触发了这个单击事件
   element-ui 的 button 子组件内部没有触发这个双击事件

   扩展双击点击触发 element-ui button 事件， 使用原生.native

8. `$parent` 和 `$children` 以及 `$ref` (七)

   - `$children`:所有子组件对象的数组
   - `$parent`:代表父组件对象

   - 父组件当中可以通过 `$children` 找到所有的子组件去操作子组件的数据(当然可以找孙子组件)
   - 子组件当中可以通过 `$parent` 找到父组件(当然可以继续找爷爷组件) 操作父组件的数据

9. 扩展: 多个组件有部分相同的 js 代码

   - html js css 相同 封装组件

   - 单个组件 js 代码重复 封装函数

   - 不同的组件 js 代码重复 封装混合

   - 实现组件之间 js 代码的复用 利用 vue 的 mixin 技术 参考官网

   - 比如多个组件的 methods 里面很多函数都是重复的，那么我们可以定义单独的模块去把这些相同的代码定义到外部

     ```js
     export const xxxMixin = {
       methods: {
         // 重复的代码写在这
       },
     };
     ```

10. 作用域插槽(八)

- 适用: 父子之间
  数据是在父组件当中的，数据是要给子组件去展示的(vfor)
  展示的过程当中，数据的结构子组件说了不算，是由父组件决定的

- 父组件要把需要子组件展示的数据传递给子组件
  子组件在展示的过程当中，需要改变结构的数据传回给父组件
  父组件再把结果和数据一并传回给子组件

12. Vuex (九)

- 适用于所有场合 根据项目大小决定是否使用
- 5 个核心概念
  state
  mutations
  actions
  getters
  modules

13. 消息的订阅和发布 PubSubJS (十) 参考基友

- 适用于所有场合 代码类似全局事件总线
- vue 中几乎不用
- PubSubJS 要引入包来实现消息订阅和发布，会增加项目打包的体积
