[toc]

# vue

## 1. 初识 vue

- `<div id="root">` 是一个容器，容器中写的不是原始 html 代码，而是 Vue 的模板代码。
- {{xxx}},xxx 会自动读取 data 中的 xxx 属性，xxx 当表达式去解析

## 2. 模板语法

1. 插值语法：
   功能：用于解析**标签体**内容
   写法：{{xxx}}，xxx 是 js 表达式，且可以自动读取到 data 中的属性
2. 指令语法：
   功能：用于解析标签(包括：标签属性、标签体内容、绑定事件...)
   举例：`v-bind:href="xxx"` 或 简写为 `:href="xxx"`

## 3. 数据绑定

1. 单向数据绑定(v-bind)：数据只能从 data 流向页面
2. 双向数据绑定(v-model)：数据不仅能从 data 流向页面，还可以从页面流向 data
   备注：
   - 双向数据绑定一般都是针对表单类元素
   - v-model:value 可以简写为 v-model，因为 v-model 默认收集 value 值。

## 4. MVVM 模型

1. M：模型(Model) ：对应 data 中的数据
2. V：视图(View) ：模板代码
3. VM：视图模型(ViewModel) ： Vue 实例对象
   ![](/vue/vue_basic/基础笔记/img/MVVM.png)

## 5. data 与 el 的 2 种写法

1. el 有 2 种写法：
   - new Vue 时候直接传递 el 属性
   - 先 new Vue 再通过 vm.$mount('#root')指定 el 属性
2. data 有 2 种写法
   - 对象式: 非组件化编码时可以写对象，也可以写函数。
   - 函数式：组件化编码必须使用函数式的 data。
3. Vue 中的一个最最重要的原则：
   - 由 Vue 所调用的函数，一定不要写成箭头函数，一旦写了箭头函数，this 就不不再是 Vue 实例了

## 6. 关于 Vue 中的数据代理

1. Vue 中的数据代理
   通过 vm 对象来代理 data 对象中属性的操作（读/写）
2. Vue 中数据代理的好处
   更加方便的操作 data 中的数据
3. 基本原理
   通过 Object.defineProperty()把 data 对象中所有属性添加到 vm 上。
   为每一个添加到 vm 上的属性，都指定一个 getter/setter。
   在 getter/setter 内部去操作（读/写）data 中对应的属性。
4. 扩展思考？为什么要先收集在`_data` 中，然后再代理出去呢？
   更高效的监视数据（直接收集到 vm 上会导致监视效率太低）

> 不使用框架进行编码时，什么时候用 defineProperty？
> 要追加的属性，来自于其他值的加工(复习里的第三、四例)

## 7. 事件处理

- 事件绑定注意事项：
  1. 事件的回调都配置在 methods 对象中
  2. methods 中的函数，都是被 Vue 所管理的函数，this 的指向是 vm 或 组件实例对象
  3. methods 中的配置的函数，不要用箭头函数！！！！，否则 this 丢失
- 传递参数
  1. 可以不写括号，默认传递 event 事件
  2. 可以传参，通常第一个参数是事件`$event`，后面跟要传递的参数，可以通过`event.target`找到事件源。
- 事件修饰符
  1. prevent 阻止默认行为
  2. stop 阻止冒泡
  3. once 事件只触发一次
  4. capture 使用事件的捕获模式
  5. self 只有 event.target 是当前操作的元素时才触发事件
  6. passive 事件的默认行为立即执行，无需等待事件回调执行完毕
  7. 键盘事件：
     1. 单词事件 enter、esc 等(包括 arrow-left 左箭头，可以通过`event.key`找到按键名)
     2. 数字事件 可以直接写键盘事件的 keyCode

## 8. 计算属性

1. 定义：要用的属性不存在，要通过已有属性计算得来。
2. 原理：底层借助了 Objcet.defineproperty 方法提供的 getter 和 setter。
3. get 函数什么时候执行？
   - 初次读取时会执行一次。
   - 当依赖的数据发生改变时会被再次调用。
4. 优势：与 methods 实现相比，内部有**缓存机制**（复用），效率更高，调试方便。
5. 备注：
   - 计算属性最终会出现在 vm 上，直接读取使用即可。
   - 如果计算属性要被修改，那必须写 set 函数去响应修改，且 set 中要引起计算时依赖的数据发生改变。

## 9. 监视属性 watch

1. 当被监视的属性变化时, 回调函数自动调用, 进行相关操作
2. 监视的属性必须存在，才能进行监视！！
3. 监视的两种写法：

   - new Vue 时传入 watch 配置
   - 通过 vm.$watch 监视

4. 深度监视：

   - Vue 中的 watch 默认不监测对象内部值的改变（一层）。
   - 配置 deep:true 可以监测对象内部值改变（多层）。

5. 备注：
   - Vue 自身可以监测对象内部值的改变，但 Vue 提供的 watch 默认不可以！
   - 使用 watch 时根据数据的具体结构，决定是否采用深度监视。

> computed 和 watch 之间的区别：
>
> 1.  只要是 computed 能完成的功能，watch 都可以完成
> 2.  watch 能完成的功能，computed 不一定能完成，例如：watch 可以进行异步操作
>
> 两个重要的小原则：
>
> 1. 所有被 Vue 管理的函数，最好写成普通函数，这样 this 的指向才是 vm 或 组件实例对象。
> 2. 所有不被 Vue 所管理的函数（定时器的回调函数、ajax 的回调函数等、Promise 的回调函数），最好写成箭头函数，这样 this 的指向才是 vm 或 组件实例对象。
>
> ​ 这样 this 的指向才是 vm 或 组件实例对象。

## 10. 绑定样式

1. 绑定 class 样式 :class="xxx" xxx 可以是字符串、对象、数组
   字符串写法适用于：类名不确定，要动态获取。
   对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。
   数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。
2. 绑定 style 样式
   :style="{fontSize: xxx}" 其中 xxx 是动态值。
   :style="[a,b]"其中 a、b 是样式对象。

## 11. 条件渲染

1. v-if:
   适用于：切换频率很低的场景
   特点：不展示的 DOM 节点直接被删除
   注意：v-if 可以和:v-else-if、v-else 一起使用，但要求结构不能被“打断”。
2. v-show:
   适用于：切换频率很高的场景
   特点：不展示的 DOM 节点没有被删除，仅仅是使用样式隐藏掉
3. 备注：使用 v-if 的时，元素可能无法获取到，而使用 v-show 一定可以获取到。

## 12. 列表渲染

- v-for 指令
  1. 用于展示列表数据
  2. 语法：v-for="(item, index) in xxx" :key="yyy"
  3. 可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）
- 想要对数据加工后再展示，且不想破坏原数据，最好用计算属性。
- Vue 数据绑定的原理
  1. vue 会监视 data 中所有对象层次的属性
  2. 对象中的属性数据通过添加 set 方法来来实现监视
  3. 数组中也实现了监视: 重写数组一系列更新元素的方法(更改原数组的方法)，做了两件事：
     > 调用原生对应的方法对数组进行处理
     > 更新界面

### Vue 监视数据的原理

1. vue 会监视 data 中所有层次的数据。
2. 如何监测对象中的数据？
   ​- 通过 setter 实现监视，且要在 new Vue 时就传入要监测的数据。
   - 1. 对象中后追加的属性，Vue 默认不做响应式处理
   - 2. 如需给后添加的属性做响应式，请使用如下 API：
        ​ - Vue.set(target，propertyName/index，value) 或
        ​ - vm.$set(target，propertyName/index，value)
3. 如何监测数组中的数据？
   ​- 通过包裹数组更新元素的方法实现，本质就是做了两件事：
   - 1. 调用原生对应的方法对数组进行更新。
   - 2. 重新解析模板，进而更新页面。
4. 在 Vue 修改数组中的某个元素一定要用如下方法：
   - 使用这些 API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()
   - Vue.set() 或 vm.$set()
     > 特别注意：Vue.set() 和 vm.$set() 不能给 vm 或 vm 的根数据对象 添加属性！！！

## 13. 收集表单数据

- 若是：`<input type="text"/>`，则 v-model 收集的是 value 值，用户输入的就是 value 值。
- 若是：`<input type="radio"/>`，则 v-model 收集的是 value 值，且要给标签配置 value 值。
- 若是：`<input type="checkbox"/>`
  1. 没有配置 input 的 value 属性，那么收集的的就是 checked（勾选 or 未勾选，是布尔值）
  2. 配置 input 的 value 属性:
     > v-model 的初始值是非数组，那么收集的的就是 checked（勾选 or 未勾选，是布尔值）
     > v-model 的初始值是数组，那么收集的的就是 value 组成的数组
- 备注：v-model 的三个修饰符：
  1. lazy：失去焦点再收集数据
  2. number：输入字符串转为有效的数字
  3. trim：输入首尾空格过滤

## 14. 过滤器

1. 定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。
2. 语法：
   - 注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}
   - 使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = "xxx | 过滤器名"
3. 备注：
   - 过滤器也可以接收额外参数、多个过滤器也可以串联
   - 并没有改变原本的数据, 是产生新的对应的数据

## 15. 内置指令

- v-bind：单向绑定解析表达式, 可简写为 :xxx
- v-model：双向数据绑定
- v-for：遍历数组/对象/字符串
- v-on：绑定事件监听, 可简写为@
- v-if：条件渲染（动态控制节点是否存存在）
- v-else：条件渲染（动态控制节点是否存存在）
- v-show：条件渲染 (动态控制节点是否展示)
- v-text 指令：
  1. 作用：向其所在的节点中渲染文本内容。
  2. 与插值语法的区别：v-text 会替换掉节点中的内容，{{xx}}则不会。
- v-html 指令：
  1. 作用：向指定节点中渲染包含 html 结构的内容。
  2. 与插值语法的区别：
     - v-html 会替换掉节点中所有的内容，{{xx}}则不会。
     - v-html 可以识别 html 结构。
  3. 严重注意：v-html 有安全性问题！！！！
     - 在网站上动态渲染任意 HTML 是非常危险的，容易导致 XSS 攻击。
     - 一定要在可信的内容上使用 v-html，永不要用在用户提交的内容上！
- v-cloak 指令（没有值）：
  1. 本质是一个特殊属性，Vue 实例创建完毕并接管容器后，会删掉 v-cloak 属性。
  2. 使用 css 配合 v-cloak 可以解决网速慢时页面展示出 {{xxx}} 的问题。
- v-once 指令：
  1. v-once 所在节点在初次动态渲染后，就视为静态内容了。
  2. 以后数据的改变不会引起 v-once 所在结构的更新，可以用于优化性能。
- v-pre 指令：
  1. 跳过其所在节点的编译过程。
  2. 可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。

## 16. 自定义指令

- 定义语法：
  1. 局部指令：
     new Vue({ directives:{指令名:配置对象} }) 或 new Vue({ directives{ 指令名:回调函数 } })
  2. 全局指令：
     Vue.directive(指令名,配置对象) 或 Vue.directive(指令名,回调函数)
- 配置对象中常用的 3 个回调：
  1. bind：指令与元素成功绑定时调用。
  2. inserted：指令所在元素被插入页面时调用。
  3. update：指令所在模板结构被重新解析时调用。
- 备注：
  1. 指令定义时不加 v-，但使用时要加 v-；
  2. 指令名如果是多个单词，要使用 kebab-case 命名方式，不要用 camelCase 命名。

## 17. Vue 实例的生命周期

![](/vue/vue全家桶_stu/02_原理图/vue生命周期.png)

- 生命周期：
  1. 又名：生命周期回调函数、生命周期函数、生命周期钩子。
  2. 是什么：Vue 在关键时刻帮我们调用的一些特殊名称的函数。
  3. 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。
  4. 生命周期函数中的 this 指向是 vm 或组件实例对象。
- 常用的生命周期函数：
  1. mounted: 发送 ajax 请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。
  2. beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。
- 关于销毁 Vue 实例
  1. 销毁后借助 Vue 开发者工具看不到任何信息。
  2. 销毁后自定义事件会失效，但原生 DOM 事件依然有效。
  3. 一般不会在 beforeDestroy 操作数据，因为即便操作数据，也不会再触发更新流程了。

## 组件

> 组件 => 实现应用中局部功能代码和资源的集合

1. Vue 中使用组件的三大步骤：
   - 定义组件(创建组件)
     - 用 Vue.extend(options)创建，其中 options 和 new Vue(options)时传入的那个 options 几乎一样，但也有点区别；
     - 区别如下：
       - 1. el 不要写，为什么？ ——— 最终所有的组件都要经过一个 vm 的管理，由 vm 中的 el 决定服务哪个容器。
       - 2. data 必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。
     - 备注：使用 template 可以配置组件结构。
   - 注册组件
     局部注册：靠 new Vue 的时候传入 components 选项
     全局注册：靠 Vue.component('组件名',组件)
   - 使用组件(写组件标签)
     `<school></school>`
2. 几个注意点：
   - 关于组件名:
     - 1. 一个单词组成：
          第一种写法(首字母小写)：school
          第二种写法(首字母大写)：School
     - 2. 多个单词组成：
          第一种写法(kebab-case 命名)：my-school
          第二种写法(CamelCase 命名)：MySchool (需要 Vue 脚手架支持)
     - 3. 备注：
          (1).组件名尽可能回避 HTML 中已有的元素名称，例如：h2、H2 都不行。
          (2).可以使用 name 配置项指定组件在开发者工具中呈现的名字。
   - 关于组件标签:
     - 1. 第一种写法：`<school></school>`
     - 2. 第二种写法：`<school/>`
     - 备注：不用使用脚手架时，`<school/>`会导致后续组件不能渲染。
   - 一个简写方式：
     - const school = Vue.extend(options) 可简写为：const school = options
3. 关于 VueComponent：
   - school 组件本质是一个名为 VueComponent 的构造函数，且不是程序员定义的，是 Vue.extend 生成的。
   - 我们只需要写`<school/>`或`<school></school>`，Vue 解析时会帮我们创建 school 组件的实例对象，即 Vue 帮我们执行的：new VueComponent(options)。
   - 特别注意：每次调用 Vue.extend，返回的都是一个全新的 VueComponent！！！！
   - 关于 this 指向：
     - 1. 组件配置中：
          data 函数、methods 中的函数、watch 中的函数、computed 中的函数 它们的 this 均是【VueComponent 实例对象】。
     - 2. new Vue(options)配置中：
          data 函数、methods 中的函数、watch 中的函数、computed 中的函数 它们的 this 均是【Vue 实例对象】。
   - VueComponent 的实例对象，以后简称 vc（也可称之为：组件实例对象）。
     Vue 的实例对象，以后简称 vm。
4. 一个重要的内置关系：
   - VueComponent.prototype.**proto** === Vue.prototype
   - 为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue 原型上的属性、方法。
5. 单文件组件和非单文件组件
   - 单文件组件 一个文件就是一个组件，而且文件后缀是.vue
   - 非单文件组件 所有文件都定义在一个文件中，文件后缀不是.vue
   - 非单文件组件存在的问题
     - 1. 模板编写没有提示
     - 2. 没有构建过程, 无法将 ES6 转换成 ES5
     - 3. 不支持组件的 CSS
     - 4. 真正开发中几乎不用
